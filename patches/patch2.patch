*** Begin Patch
*** Update File: styles/main.css
@@
 .toast.show { opacity: 1; transform: translateY(0); }
 
 #reconnectBanner{
   position: fixed;
   top: 0;
   left: 0;
   right: 0;
   padding: 10px 14px;
   text-align: center;
   background: rgba(255,193,7,.95);
   color: #222;
   font-weight: 600;
   letter-spacing: .3px;
   z-index: 9999;
 }
 
+/* ==== Modern, subtle visual state (glows, pulses) ==== */
+/* We rely on CSS variables set by JS: --glow-color, --glow-strength (0..1) */
+
+/* Generic device tiles: support either .device-tile or [data-device-id] */
+.device-tile,
+[data-device-id],
+.side-btn{
+  transition: box-shadow 180ms ease, outline-color 180ms ease, filter 160ms ease, transform 120ms ease;
+  will-change: box-shadow, filter, transform;
+}
+
+/* Base glow when "on"/active. Size/intensity scales with --glow-strength */
+.device-tile.is-on,
+[data-device-id].is-on,
+.side-btn.is-on{
+  --glow-color: rgba(255, 232, 170, 0.9);
+  --glow-strength: 0.55;
+  box-shadow:
+    0 0 .4rem rgba(255,255,255,.03),
+    0 0 calc(.8rem + .6rem * var(--glow-strength)) var(--glow-color),
+    0 0 calc(1.4rem + 1rem * var(--glow-strength)) color-mix(in srgb, var(--glow-color) 50%, transparent);
+  outline: 1px solid color-mix(in srgb, var(--glow-color) 45%, transparent);
+}
+
+/* One-shot pulse (add .pulse briefly on state change) */
+.device-tile.pulse,
+[data-device-id].pulse,
+.side-btn.pulse{ animation: ui-pulse .28s ease-out 1; }
+@keyframes ui-pulse{
+  0%   { filter: brightness(.96); transform: scale(1); }
+  38%  { filter: brightness(1.1); transform: scale(1.02); }
+  100% { filter: brightness(1.0); transform: scale(1); }
+}
+
+/* Lights (color-aware glow) */
+.device-tile.light.is-on,
+[data-device-id].light.is-on,
+.side-btn.light.is-on{
+  /* JS sets --glow-color to current HSL/CT color and --glow-strength from level */
+}
+
+/* Lock indicator (green safe vs red attention) */
+.side-btn.lock.locked{ --glow-color: rgba(66, 179, 113, .9); }
+.side-btn.lock.unlocked{ --glow-color: rgba(244, 96, 72, .95); }
+
+/* Thermostat mode color ring */
+.side-btn.thermostat.heating{ --glow-color: rgba(255, 148, 54, .92); }
+.side-btn.thermostat.cooling{ --glow-color: rgba(86, 175, 255, .95); }
+
+/* TV on: subtle screen glow */
+.side-btn.tv.is-on{ --glow-color: rgba(130, 180, 255, .75); }
+
+/* Music playing: small breathing dot badge */
+.side-btn.music.playing{ position: relative; }
+.side-btn.music.playing::after{
+  content: '';
+  position: absolute;
+  right: 8px; top: 8px;
+  width: 6px; height: 6px;
+  border-radius: 50%;
+  background: currentColor;
+  opacity: .6;
+  animation: ui-breath 1.2s ease-in-out infinite;
+}
+@keyframes ui-breath{
+  0% { opacity: .35; transform: scale(1); }
+  50%{ opacity: .9;  transform: scale(1.18); }
+  100%{ opacity: .35; transform: scale(1); }
+}
+
+/* Vacuum cleaning: gentle roam to imply motion */
+.side-btn.vacuum.active{ animation: ui-roam 3s ease-in-out infinite; }
+@keyframes ui-roam{
+  0% { transform: translateX(0) }
+  50%{ transform: translateX(4px) }
+  100%{ transform: translateX(0) }
+}
+
+/* Optional hover/tap affordance (subtle) */
+.device-tile:hover,
+[data-device-id]:hover,
+.side-btn:hover{ filter: brightness(1.04); }
+.device-tile:active,
+[data-device-id]:active,
+.side-btn:active{ transform: translateY(1px); }
*** End Patch
*** Begin Patch
*** Update File: scripts/ui-manager.js
@@
 (function(){
   class UIManager {
     constructor(){
       // existing initâ€¦
       this._subscribed = false;
+      this.activeDeviceModalId = null;
+      this._bindModalTracking();
+      if (window.deviceStateManager) {
+        this.initSubscriptions();
+      } else {
+        window.addEventListener('deviceStateManager:ready', () => this.initSubscriptions(), { once: true });
+      }
     }
 
     initSubscriptions(){
       // Ensure all UI updates are driven from state changes in DeviceStateManager
       if (!window.deviceStateManager || this._subscribed) return;
       this._subscribed = true;
-      this._unsubscribe = window.deviceStateManager.subscribe((deviceId, state) => {
+      this._unsubscribe = window.deviceStateManager.subscribe((deviceId, state) => {
         try {
           // Single source of truth: draw from state manager only
           // Update any UI elements that depend on this device
           this.updateDeviceUI(deviceId, state);
           // Optionally update global paddles/indicators when relevant
-          const idStr = String(deviceId);
-          if (String(window.DEVICE_MAP?.lockId) === idStr) this.updateLockIndicator?.(state);
-          if (window.GROUPS?.bedroomLights?.includes?.(idStr)) this.updatePaddleSwitchUI?.();
+          const idStr = String(deviceId);
+          if (String(window.DEVICE_MAP?.lockId) === idStr) this.updateLockIndicator?.(state);
+          if (this._isInGroup('bedroomLights', idStr)) this.updatePaddleSwitchUI?.();
+
+          // Live-update open device modal (if any)
+          if (this.activeDeviceModalId && String(this.activeDeviceModalId) === idStr) {
+            const latest = window.deviceStateManager.getDevice(deviceId) || {};
+            if (this.renderOpenDeviceModal?.(deviceId, latest)) {
+              // handled by custom renderer
+            } else if (window.renderDeviceControls) {
+              window.renderDeviceControls(deviceId, latest);
+            }
+          }
         } catch(e){
           console.error('UI render on state update failed', e);
         }
       });
     }
 
     updateDeviceUI(deviceId, state){
       // Idempotent rendering based on state capabilities
       if (!state || typeof state !== 'object' || Array.isArray(state)) return;
       const idStr = String(deviceId);
       // Lights (switch/level/color/ct)
       if ('switch' in state || 'level' in state || 'hue' in state || 'colorTemperature' in state){
-        this.updateLightTile?.(idStr, state);
+        this.updateLightTile?.(idStr, state);
       }
       // Lock
       if ('lock' in state || 'contact' in state || 'battery' in state){
         this.updateLockTile?.(idStr, state);
       }
       // Thermostat
       if ('thermostatMode' in state || 'thermostatOperatingState' in state || 'coolingSetpoint' in state || 'heatingSetpoint' in state){
         this.updateThermostatUI?.(idStr, state);
       }
       // TV / Media (Roku)
       if ('transportStatus' in state || 'application' in state || 'power' in state || 'mediaInputSource' in state){
         this.updateMediaUI?.(idStr, state);
       }
       // Vacuum (Roborock)
       if ('state' in state || 'battery' in state || 'dockError' in state){
         this.updateVacuumUI?.(idStr, state);
       }
     }
 
+    /* ================= Helpers & group checks ================= */
+    _isInGroup(groupName, idStr){
+      const arr = window.GROUPS?.[groupName];
+      if (!Array.isArray(arr)) return false;
+      return arr.some(d => String(d) === String(idStr));
+    }
+    _findTileById(idStr){
+      return document.querySelector?.(`[data-device-id="${idStr}"]`) || document.querySelector?.(`.device-tile[data-device-id="${idStr}"]`) || null;
+    }
+    _sideBtnByTitle(title){
+      return document.querySelector?.(`.side-btn[title="${title}"]`) || null;
+    }
+    _setGlow(el, color, strength=0.6){
+      if (!el) return;
+      el.style.setProperty('--glow-color', color);
+      el.style.setProperty('--glow-strength', String(Math.max(0, Math.min(1, strength))));
+    }
+    _pulse(el){
+      if (!el) return;
+      el.classList.remove('pulse');
+      // reflow to restart animation
+      // eslint-disable-next-line no-unused-expressions
+      el.offsetWidth;
+      el.classList.add('pulse');
+    }
+    _colorFromState(state){
+      const level = Number.isFinite(state.level) ? state.level : (parseFloat(state.level) || 0);
+      if (typeof state.hue !== 'undefined' && typeof state.saturation !== 'undefined'){
+        const h = Math.max(0, Math.min(100, Number(state.hue))) * 3.6;
+        const s = Math.max(0, Math.min(100, Number(state.saturation)));
+        const l = 50;
+        return `hsl(${h}deg ${s}% ${l}%)`;
+      }
+      if (typeof state.colorTemperature !== 'undefined'){
+        const k = Math.max(1500, Math.min(9000, Number(state.colorTemperature)));
+        const t = (k - 2700) / (6500 - 2700);
+        const hue = (1 - Math.max(0, Math.min(1, t))) * 35 + Math.max(0, Math.min(1, t)) * 210;
+        return `hsl(${hue}deg 90% 60%)`;
+      }
+      return 'hsl(48deg 95% 60%)';
+    }
+    _strengthFromState(state){
+      const lvl = Number.isFinite(state.level) ? state.level : (parseFloat(state.level) || 0);
+      return Math.max(.25, Math.min(1, lvl / 100));
+    }
+
+    /* Lights: per-device tile + "Lights" side button */
+    updateLightTile(deviceId, state){
+      const isOn = (String(state.switch).toLowerCase() === 'on') || (Number(state.level) > 0);
+      const color = this._colorFromState(state);
+      const strength = this._strengthFromState(state);
+      // Per-device tile (if present)
+      const tile = this._findTileById(deviceId);
+      if (tile){
+        tile.classList.add('light');
+        tile.classList.toggle('is-on', !!isOn);
+        this._setGlow(tile, color, strength);
+        this._pulse(tile);
+      }
+      // Lights side button (aggregate signal for bedroom group)
+      const lightsBtn = this._sideBtnByTitle('Lights');
+      if (lightsBtn && this._isInGroup('bedroomLights', deviceId)){
+        lightsBtn.classList.add('light');
+        lightsBtn.classList.toggle('is-on', !!isOn);
+        this._setGlow(lightsBtn, color, strength);
+        this._pulse(lightsBtn);
+      }
+    }
+
+    /* Lock: side button or #lockIndicator */
+    updateLockTile(deviceId, state){
+      const locked = String(state.lock).toLowerCase() === 'locked';
+      const btn = this._sideBtnByTitle('Lock') || document.getElementById?.('lockIndicator');
+      if (!btn) return;
+      btn.classList.add('lock');
+      btn.classList.toggle('locked', locked);
+      btn.classList.toggle('unlocked', !locked);
+      btn.classList.toggle('is-on', true);
+      this._setGlow(btn, locked ? 'rgba(66,179,113,.9)' : 'rgba(244,96,72,.95)', .6);
+      this._pulse(btn);
+    }
+
+    /* Thermostat: color by operating state */
+    updateThermostatUI(deviceId, state){
+      const mode = String(state.thermostatOperatingState || state.thermostatMode || '').toLowerCase();
+      const btn = this._sideBtnByTitle('Thermostat');
+      if (!btn) return;
+      btn.classList.add('thermostat');
+      const heat = mode.includes('heat');
+      const cool = mode.includes('cool');
+      btn.classList.toggle('heating', heat);
+      btn.classList.toggle('cooling', cool);
+      btn.classList.toggle('is-on', heat || cool);
+      const glow = heat ? 'rgba(255,148,54,.92)' : cool ? 'rgba(86,175,255,.95)' : 'rgba(180,180,180,.4)';
+      this._setGlow(btn, glow, .55);
+      if (heat || cool) this._pulse(btn);
+    }
+
+    /* TV & Music: power / playback cues */
+    updateMediaUI(deviceId, state){
+      // TV
+      if (String(window.DEVICE_MAP?.tvId) === String(deviceId) || state.application || state.mediaInputSource || typeof state.power !== 'undefined'){
+        const tvBtn = this._sideBtnByTitle('TV');
+        if (tvBtn){
+          tvBtn.classList.add('tv');
+          const on = String(state.power || '').toLowerCase() === 'on' || !!state.application;
+          tvBtn.classList.toggle('is-on', on);
+          this._setGlow(tvBtn, 'rgba(130,180,255,.75)', on ? .6 : .35);
+          if (on) this._pulse(tvBtn);
+        }
+      }
+      // Music (simple playback pulse)
+      const playing = String(state.transportStatus || '').toLowerCase().includes('play');
+      const musicBtn = this._sideBtnByTitle('Music');
+      if (musicBtn){
+        musicBtn.classList.add('music');
+        musicBtn.classList.toggle('playing', playing);
+        musicBtn.classList.toggle('is-on', playing);
+        this._setGlow(musicBtn, 'rgba(180, 160, 255, .8)', playing ? .55 : .35);
+        if (playing) this._pulse(musicBtn);
+      }
+    }
+
+    /* Vacuum: motion + battery tint (optional) */
+    updateVacuumUI(deviceId, state){
+      const st = String(state.state || '').toLowerCase();
+      const active = /clean|auto|spot/.test(st);
+      const btn = this._sideBtnByTitle('Vacuum');
+      if (!btn) return;
+      btn.classList.add('vacuum');
+      btn.classList.toggle('active', active);
+      btn.classList.toggle('is-on', active);
+      const batt = Number(state.battery);
+      let color = 'rgba(120, 200, 120, .85)';
+      if (!Number.isNaN(batt)){
+        if (batt < 20) color = 'rgba(244, 96, 72, .95)';
+        else if (batt < 50) color = 'rgba(255, 196, 86, .95)';
+      }
+      this._setGlow(btn, color, active ? .6 : .4);
+      if (active) this._pulse(btn);
+    }
+
+    _bindModalTracking(){
+      window.addEventListener?.('dashboard:deviceModalOpen', (e) => {
+        this.activeDeviceModalId = e?.detail?.deviceId ?? null;
+      });
+      window.addEventListener?.('dashboard:deviceModalClose', () => {
+        this.activeDeviceModalId = null;
+      });
+      const originalOpen = window.openDeviceModal;
+      if (typeof originalOpen === 'function') {
+        window.openDeviceModal = (id, label, showBack) => {
+          this.activeDeviceModalId = id;
+          return originalOpen(id, label, showBack);
+        };
+      }
+    }
+
+    destroy(){
+      try { this._unsubscribe?.(); } catch {}
+      this._unsubscribe = null;
+      this._subscribed = false;
+    }
   }
 
   window.uiManager = new UIManager();
   // Ensure subscription wiring happens on load
   if (window.uiManager && window.deviceStateManager){
     window.uiManager.initSubscriptions?.();
   }
 })();
*** End Patch
*** Begin Patch
*** Update File: scripts/state-manager.js
@@
 class DeviceStateManager {
   constructor(){
     this.devices = new Map();
     this.listeners = new Set();
     this.updateQueue = new Map();
     this.debounceDelay = 100;
     this.lastEventTs = new Map(); // dedupe/order guard
+    // Notify the app once the manager is ready so UI can wire safely
+    try {
+      window.dispatchEvent(new CustomEvent('deviceStateManager:ready'));
+    } catch {}
   }
@@
-  subscribe(fn){
-    if (typeof fn === 'function') this.listeners.add(fn);
-  }
+  subscribe(fn){
+    if (typeof fn !== 'function') return () => {};
+    this.listeners.add(fn);
+    // Return an unsubscribe function so callers can cleanly detach
+    return () => { try { this.listeners.delete(fn); } catch {} };
+  }
*** End Patch
